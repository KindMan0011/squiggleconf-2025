#+TITLE: Rust for High-Performance Systems Design
#+AUTHOR: SquiggleConf 2025 Team
#+DATE: <2025-06-18 Wed>
#+STARTUP: overview
#+PROPERTY: header-args:rust :results output

* Rust for Senior & Principal Engineers

This tutorial focuses on advanced Rust techniques for high-performance systems, compiler development, and developer tooling.

** Zero-Cost Abstractions & Compiler Intrinsics

Understanding how Rust's abstractions compile away to efficient code:

#+begin_src rust :tangle src/zero_cost.rs
//! Understanding and leveraging zero-cost abstractions in Rust
//! 
//! This module demonstrates:
//! 1. How traits compile to static dispatch
//! 2. Leveraging LLVM intrinsics
//! 3. Using const generics and const evaluation
//! 4. Custom DSLs that compile away

#![feature(intrinsics)]
#![feature(const_trait_impl)]
#![feature(adt_const_params)]
#![feature(optimize_attribute)]

use std::fmt::Debug;
use std::marker::PhantomData;
use std::mem;
use std::time::Instant;

// External intrinsics that map to LLVM instructions
extern "rust-intrinsic" {
    fn ctpop<T>(x: T) -> T;  // Count the number of set bits
    fn ctlz<T>(x: T) -> T;   // Count leading zeros
    fn cttz<T>(x: T) -> T;   // Count trailing zeros
    fn bswap<T>(x: T) -> T;  // Byte swap
    fn bitreverse<T>(x: T) -> T; // Reverse bits
}

// Trait for bit manipulation operations with const implementations
#[const_trait]
pub trait BitOps {
    fn count_ones(self) -> u32;
    fn count_zeros(self) -> u32;
    fn leading_zeros(self) -> u32;
    fn trailing_zeros(self) -> u32;
    fn reverse_bits(self) -> Self;
    fn byte_swap(self) -> Self;
}

// Implementation that will be optimized to direct LLVM instructions
impl const BitOps for u64 {
    #[inline(always)]
    fn count_ones(self) -> u32 {
        unsafe { ctpop(self) as u32 }
    }

    #[inline(always)]
    fn count_zeros(self) -> u32 {
        (!self).count_ones()
    }

    #[inline(always)]
    fn leading_zeros(self) -> u32 {
        unsafe { ctlz(self) as u32 }
    }

    #[inline(always)]
    fn trailing_zeros(self) -> u32 {
        unsafe { cttz(self) as u32 }
    }

    #[inline(always)]
    fn reverse_bits(self) -> Self {
        unsafe { bitreverse(self) }
    }

    #[inline(always)]
    fn byte_swap(self) -> Self {
        unsafe { bswap(self) }
    }
}

// Const generic that computes values at compile time
#[derive(Debug)]
struct Matrix<const ROWS: usize, const COLS: usize, T> {
    data: [[T; COLS]; ROWS],
    _marker: PhantomData<T>,
}

impl<const ROWS: usize, const COLS: usize, T: Copy + Default> Matrix<ROWS, COLS, T> {
    // Creates a matrix filled with default values
    fn new() -> Self {
        Self {
            data: [[T::default(); COLS]; ROWS],
            _marker: PhantomData,
        }
    }

    // Const function to get dimensions
    const fn dimensions(&self) -> (usize, usize) {
        (ROWS, COLS)
    }
}

// Type-level state machine DSL for compile-time verification
// Phantom types enforce state transitions
struct StateMachine<S> {
    _state: PhantomData<S>,
}

// States in our state machine
struct Initial;
struct Running;
struct Paused;
struct Stopped;

impl StateMachine<Initial> {
    fn new() -> Self {
        Self { _state: PhantomData }
    }

    fn start(self) -> StateMachine<Running> {
        println!("Starting state machine");
        StateMachine { _state: PhantomData }
    }
}

impl StateMachine<Running> {
    fn pause(self) -> StateMachine<Paused> {
        println!("Pausing state machine");
        StateMachine { _state: PhantomData }
    }

    fn stop(self) -> StateMachine<Stopped> {
        println!("Stopping state machine");
        StateMachine { _state: PhantomData }
    }
}

impl StateMachine<Paused> {
    fn resume(self) -> StateMachine<Running> {
        println!("Resuming state machine");
        StateMachine { _state: PhantomData }
    }

    fn stop(self) -> StateMachine<Stopped> {
        println!("Stopping state machine from paused state");
        StateMachine { _state: PhantomData }
    }
}

impl StateMachine<Stopped> {
    fn reset(self) -> StateMachine<Initial> {
        println!("Resetting state machine");
        StateMachine { _state: PhantomData }
    }
}

// Trait for a domain-specific language that will be optimized away
trait QueryBuilder {
    type Output;
    
    fn filter<F>(self, predicate: F) -> Self where F: Fn(&str) -> bool;
    fn map<T, F>(self, transform: F) -> T where F: Fn(Self::Output) -> T, T: QueryBuilder;
    fn execute(self) -> Self::Output;
}

// Dummy implementation to show the concept
struct Query<T> {
    data: Vec<T>,
}

impl<T: Clone> QueryBuilder for Query<T> {
    type Output = Vec<T>;
    
    fn filter<F>(mut self, predicate: F) -> Self 
    where 
        F: Fn(&str) -> bool 
    {
        // In a real implementation, this would apply the filter logic
        // but at compile time, optimizations would inline this
        println!("Applying filter");
        self
    }
    
    fn map<U, F>(self, transform: F) -> U 
    where 
        F: Fn(Self::Output) -> U,
        U: QueryBuilder 
    {
        // Transform would also be inlined
        println!("Applying transformation");
        transform(self.data)
    }
    
    fn execute(self) -> Self::Output {
        // Final execution
        self.data
    }
}

#[optimize(size)]
fn main() {
    // Example 1: Bit operations that compile to single CPU instructions
    let value: u64 = 0xDEADBEEF;
    println!("Value: {:#X}", value);
    println!("  Ones: {}", value.count_ones());
    println!("  Leading zeros: {}", value.leading_zeros());
    println!("  Trailing zeros: {}", value.trailing_zeros());
    println!("  Byte swapped: {:#X}", value.byte_swap());
    println!("  Bit reversed: {:#X}", value.reverse_bits());
    
    // Example 2: Const generics for compile-time computation
    let matrix: Matrix<3, 4, i32> = Matrix::new();
    let (rows, cols) = matrix.dimensions();
    println!("\nMatrix dimensions: {}x{}", rows, cols);
    
    // Example 3: Type-state pattern for compile-time state verification
    let machine = StateMachine::new();
    
    // Valid state transitions
    let machine = machine.start();
    let machine = machine.pause();
    let machine = machine.resume();
    let machine = machine.stop();
    let machine = machine.reset();
    
    // This would cause a compilation error (cannot call start twice):
    // let invalid = machine.start().start();
    
    // Example 4: Zero-cost query DSL
    let data = Query { data: vec![1, 2, 3, 4, 5] };
    
    // Measure performance (should be virtually identical to hand-written code)
    let start = Instant::now();
    
    let result = data
        .filter(|s| s.len() > 2)
        .map(|v| Query { data: v.iter().map(|&x| x * 2).collect() })
        .execute();
        
    let duration = start.elapsed();
    
    println!("\nQuery executed in: {:?}", duration);
    println!("Result length: {}", result.len());
    
    // Example 5: Size optimizations
    println!("\nFunction size optimized: {}", std::any::type_name::<fn()>());
    println!("Size of main function: {} bytes", mem::size_of_val(&main as &dyn Fn()));
}
#+end_src

** Advanced Ownership & Memory Management

Sophisticated techniques for fine-grained memory control:

#+begin_src rust :tangle src/advanced_ownership.rs
//! Advanced ownership and memory management techniques
//! 
//! For systems with specific memory requirements and constraints

#![feature(allocator_api)]
#![feature(slice_ptr_get)]
#![feature(slice_ptr_len)]
#![feature(strict_provenance)]

use std::alloc::{Allocator, Global, Layout};
use std::cell::{Cell, RefCell, UnsafeCell};
use std::mem::{self, MaybeUninit};
use std::ptr::{self, NonNull};
use std::rc::Rc;
use std::sync::Arc;

// Custom arena allocator for reducing allocation overhead
struct BumpAllocator {
    // Memory arena
    arena: UnsafeCell<Vec<u8>>,
    // Current allocation position
    position: Cell<usize>,
}

unsafe impl Allocator for BumpAllocator {
    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, std::alloc::AllocError> {
        let arena = unsafe { &mut *self.arena.get() };
        let position = self.position.get();
        
        // Ensure alignment
        let align_offset = position % layout.align();
        let aligned_position = if align_offset == 0 {
            position
        } else {
            position + (layout.align() - align_offset)
        };
        
        // Calculate new position
        let new_position = aligned_position + layout.size();
        
        // Check if we have enough space
        if new_position > arena.len() {
            // Not enough space, fall back to global allocator
            let layout = Layout::from_size_align(
                layout.size().max(4096),
                layout.align()
            ).unwrap();
            
            // Allocate new memory
            let new_capacity = arena.len() + layout.size();
            arena.reserve(new_capacity - arena.len());
            arena.resize(new_capacity, 0);
        }
        
        // Update position
        self.position.set(new_position);
        
        // Return pointer to allocated memory
        let ptr = unsafe { NonNull::new_unchecked(arena.as_mut_ptr().add(aligned_position)) };
        let ptr = NonNull::slice_from_raw_parts(ptr, layout.size());
        Ok(ptr)
    }
    
    unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {
        // No-op: memory is only freed when the allocator is dropped
    }
}

impl BumpAllocator {
    fn new(initial_capacity: usize) -> Self {
        Self {
            arena: UnsafeCell::new(Vec::with_capacity(initial_capacity)),
            position: Cell::new(0),
        }
    }
    
    fn reset(&self) {
        self.position.set(0);
    }
}

// Example of a custom data structure that uses arena allocation
struct ArenaVec<T, A: Allocator = Global> {
    ptr: NonNull<T>,
    len: usize,
    capacity: usize,
    allocator: A,
}

impl<T> ArenaVec<T, BumpAllocator> {
    fn new(allocator: BumpAllocator) -> Self {
        Self {
            ptr: NonNull::dangling(),
            len: 0,
            capacity: 0,
            allocator,
        }
    }
    
    fn push(&mut self, value: T) {
        if self.len == self.capacity {
            // Need to reallocate
            let new_capacity = if self.capacity == 0 { 4 } else { self.capacity * 2 };
            let new_layout = Layout::array::<T>(new_capacity).unwrap();
            
            let new_ptr = match self.allocator.allocate(new_layout) {
                Ok(ptr) => ptr.cast::<T>().as_ptr(),
                Err(_) => panic!("Failed to allocate memory"),
            };
            
            // Copy existing elements if any
            if self.len > 0 {
                unsafe {
                    ptr::copy_nonoverlapping(self.ptr.as_ptr(), new_ptr, self.len);
                }
            }
            
            self.ptr = unsafe { NonNull::new_unchecked(new_ptr) };
            self.capacity = new_capacity;
        }
        
        // Add new element
        unsafe {
            ptr::write(self.ptr.as_ptr().add(self.len), value);
        }
        self.len += 1;
    }
    
    fn get(&self, index: usize) -> Option<&T> {
        if index >= self.len {
            None
        } else {
            unsafe {
                Some(&*self.ptr.as_ptr().add(index))
            }
        }
    }
}

impl<T, A: Allocator> Drop for ArenaVec<T, A> {
    fn drop(&mut self) {
        // Drop all elements
        for i in 0..self.len {
            unsafe {
                ptr::drop_in_place(self.ptr.as_ptr().add(i));
            }
        }
        
        // No need to deallocate when using BumpAllocator
        // It will be reset or freed when the allocator itself is dropped
    }
}

// Safe interior mutability with compile-time guarantees
struct Slot<T> {
    // Data is wrapped in UnsafeCell to allow interior mutability
    data: UnsafeCell<T>,
    // Flag to track if data is borrowed
    borrowed: Cell<bool>,
}

impl<T> Slot<T> {
    fn new(value: T) -> Self {
        Self {
            data: UnsafeCell::new(value),
            borrowed: Cell::new(false),
        }
    }
    
    // Safe borrow method
    fn borrow(&self) -> Option<&T> {
        if self.borrowed.get() {
            None
        } else {
            self.borrowed.set(true);
            // Safety: We've checked and set the borrowed flag
            Some(unsafe { &*self.data.get() })
        }
    }
    
    // Safe mutable borrow method
    fn borrow_mut(&self) -> Option<&mut T> {
        if self.borrowed.get() {
            None
        } else {
            self.borrowed.set(true);
            // Safety: We've checked and set the borrowed flag
            Some(unsafe { &mut *self.data.get() })
        }
    }
    
    // Release the borrow
    fn release(&self) {
        self.borrowed.set(false);
    }
}

impl<T> Drop for Slot<T> {
    fn drop(&mut self) {
        // No need to do anything special here
        // The UnsafeCell will drop the inner value
    }
}

// Type for implementing double-ended shared mutable queues
struct SharedQueue<T> {
    data: RefCell<Vec<T>>,
}

impl<T> SharedQueue<T> {
    fn new() -> Self {
        Self {
            data: RefCell::new(Vec::new()),
        }
    }
    
    fn push_back(&self, value: T) {
        self.data.borrow_mut().push(value);
    }
    
    fn push_front(&self, value: T) {
        self.data.borrow_mut().insert(0, value);
    }
    
    fn pop_back(&self) -> Option<T> {
        self.data.borrow_mut().pop()
    }
    
    fn pop_front(&self) -> Option<T> {
        if self.data.borrow().is_empty() {
            None
        } else {
            Some(self.data.borrow_mut().remove(0))
        }
    }
    
    fn len(&self) -> usize {
        self.data.borrow().len()
    }
}

// Type-safe work stealing queue for parallel processing
struct WorkStealingQueue<T> {
    local: RefCell<Vec<T>>,
    shared: Arc<SharedQueue<T>>,
}

impl<T> WorkStealingQueue<T> {
    fn new() -> Self {
        Self {
            local: RefCell::new(Vec::new()),
            shared: Arc::new(SharedQueue::new()),
        }
    }
    
    fn clone_stealer(&self) -> WorkStealer<T> {
        WorkStealer {
            shared: Arc::clone(&self.shared),
        }
    }
    
    fn push(&self, value: T) {
        self.local.borrow_mut().push(value);
    }
    
    fn pop(&self) -> Option<T> {
        // Try local queue first
        if let Some(value) = self.local.borrow_mut().pop() {
            return Some(value);
        }
        
        // Try stealing from shared queue
        self.shared.pop_back()
    }
    
    fn share(&self) {
        // Move some items to shared queue
        let mut local = self.local.borrow_mut();
        if local.len() > 1 {
            let half = local.len() / 2;
            for _ in 0..half {
                if let Some(value) = local.pop() {
                    self.shared.push_back(value);
                }
            }
        }
    }
}

struct WorkStealer<T> {
    shared: Arc<SharedQueue<T>>,
}

impl<T> WorkStealer<T> {
    fn steal(&self) -> Option<T> {
        self.shared.pop_front()
    }
}

// Memory pool for object reuse to avoid allocations
struct Pool<T> {
    objects: RefCell<Vec<T>>,
}

impl<T> Pool<T> {
    fn new() -> Self {
        Self {
            objects: RefCell::new(Vec::new()),
        }
    }
    
    fn acquire<F>(&self, factory: F) -> PoolGuard<T>
    where
        F: FnOnce() -> T,
    {
        let obj = self.objects.borrow_mut().pop().unwrap_or_else(factory);
        PoolGuard {
            obj: Some(obj),
            pool: self,
        }
    }
    
    fn return_object(&self, obj: T) {
        self.objects.borrow_mut().push(obj);
    }
}

struct PoolGuard<'a, T> {
    obj: Option<T>,
    pool: &'a Pool<T>,
}

impl<'a, T> std::ops::Deref for PoolGuard<'a, T> {
    type Target = T;
    
    fn deref(&self) -> &Self::Target {
        self.obj.as_ref().unwrap()
    }
}

impl<'a, T> std::ops::DerefMut for PoolGuard<'a, T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.obj.as_mut().unwrap()
    }
}

impl<'a, T> Drop for PoolGuard<'a, T> {
    fn drop(&mut self) {
        if let Some(obj) = self.obj.take() {
            self.pool.return_object(obj);
        }
    }
}

// Customizable reference counting with hooks for memory reclamation
struct CustomRc<T> {
    data: NonNull<RcData<T>>,
}

struct RcData<T> {
    strong: Cell<usize>,
    weak: Cell<usize>,
    value: T,
}

impl<T> CustomRc<T> {
    fn new(value: T) -> Self {
        let data = Box::new(RcData {
            strong: Cell::new(1),
            weak: Cell::new(0),
            value,
        });
        
        Self {
            data: unsafe { NonNull::new_unchecked(Box::into_raw(data)) },
        }
    }
    
    fn strong_count(&self) -> usize {
        unsafe { (*self.data.as_ptr()).strong.get() }
    }
    
    fn weak_count(&self) -> usize {
        unsafe { (*self.data.as_ptr()).weak.get() }
    }
    
    fn downgrade(&self) -> CustomWeak<T> {
        unsafe {
            let weak = (*self.data.as_ptr()).weak.get();
            (*self.data.as_ptr()).weak.set(weak + 1);
        }
        
        CustomWeak { data: self.data }
    }
    
    fn get_ref(&self) -> &T {
        unsafe { &(*self.data.as_ptr()).value }
    }
}

impl<T> Clone for CustomRc<T> {
    fn clone(&self) -> Self {
        unsafe {
            let strong = (*self.data.as_ptr()).strong.get();
            (*self.data.as_ptr()).strong.set(strong + 1);
        }
        
        Self { data: self.data }
    }
}

impl<T> Drop for CustomRc<T> {
    fn drop(&mut self) {
        unsafe {
            let strong = (*self.data.as_ptr()).strong.get();
            if strong == 1 {
                // Last strong reference, drop the value
                let weak = (*self.data.as_ptr()).weak.get();
                if weak == 0 {
                    // No weak references, free the memory
                    drop(Box::from_raw(self.data.as_ptr()));
                } else {
                    // Still have weak references, just drop the value
                    ptr::drop_in_place(&mut (*self.data.as_ptr()).value);
                    (*self.data.as_ptr()).strong.set(0);
                }
            } else {
                // More strong references exist
                (*self.data.as_ptr()).strong.set(strong - 1);
            }
        }
    }
}

struct CustomWeak<T> {
    data: NonNull<RcData<T>>,
}

impl<T> CustomWeak<T> {
    fn upgrade(&self) -> Option<CustomRc<T>> {
        unsafe {
            let strong = (*self.data.as_ptr()).strong.get();
            if strong == 0 {
                // Original value was dropped
                None
            } else {
                // Increment strong count
                (*self.data.as_ptr()).strong.set(strong + 1);
                Some(CustomRc { data: self.data })
            }
        }
    }
}

impl<T> Clone for CustomWeak<T> {
    fn clone(&self) -> Self {
        unsafe {
            let weak = (*self.data.as_ptr()).weak.get();
            (*self.data.as_ptr()).weak.set(weak + 1);
        }
        
        Self { data: self.data }
    }
}

impl<T> Drop for CustomWeak<T> {
    fn drop(&mut self) {
        unsafe {
            let weak = (*self.data.as_ptr()).weak.get();
            if weak == 1 {
                // Last weak reference
                let strong = (*self.data.as_ptr()).strong.get();
                if strong == 0 {
                    // No strong references, free the memory
                    drop(Box::from_raw(self.data.as_ptr()));
                } else {
                    // Still have strong references
                    (*self.data.as_ptr()).weak.set(0);
                }
            } else {
                // More weak references exist
                (*self.data.as_ptr()).weak.set(weak - 1);
            }
        }
    }
}

// Uninitialized memory manipulation for performance-critical code
struct RingBuffer<T> {
    buffer: Box<[MaybeUninit<T>]>,
    head: usize,
    tail: usize,
    capacity: usize,
    len: usize,
}

impl<T> RingBuffer<T> {
    fn new(capacity: usize) -> Self {
        let mut buffer = Vec::with_capacity(capacity);
        // Safety: We're creating uninitialized memory, which is valid for MaybeUninit
        buffer.resize_with(capacity, || MaybeUninit::uninit());
        
        Self {
            buffer: buffer.into_boxed_slice(),
            head: 0,
            tail: 0,
            capacity,
            len: 0,
        }
    }
    
    fn push_back(&mut self, value: T) -> Result<(), T> {
        if self.len == self.capacity {
            return Err(value);
        }
        
        // Write value to buffer
        self.buffer[self.tail] = MaybeUninit::new(value);
        
        // Update tail and length
        self.tail = (self.tail + 1) % self.capacity;
        self.len += 1;
        
        Ok(())
    }
    
    fn pop_front(&mut self) -> Option<T> {
        if self.len == 0 {
            return None;
        }
        
        // Read value from buffer
        let value = unsafe {
            // Safety: We know this slot is initialized
            ptr::read(self.buffer[self.head].as_ptr())
        };
        
        // Update head and length
        self.head = (self.head + 1) % self.capacity;
        self.len -= 1;
        
        Some(value)
    }
    
    fn len(&self) -> usize {
        self.len
    }
    
    fn capacity(&self) -> usize {
        self.capacity
    }
}

impl<T> Drop for RingBuffer<T> {
    fn drop(&mut self) {
        // Drop all initialized elements
        while self.pop_front().is_some() {}
    }
}

fn main() {
    // Example 1: Custom Arena Allocator
    println!("=== Arena Allocator Example ===");
    let allocator = BumpAllocator::new(1024);
    let mut vec = ArenaVec::<i32, _>::new(allocator);
    
    for i in 0..10 {
        vec.push(i);
    }
    
    for i in 0..10 {
        println!("vec[{}] = {:?}", i, vec.get(i));
    }
    
    // Example 2: Slot for safe interior mutability
    println!("\n=== Slot Example ===");
    let slot = Slot::new(42);
    
    {
        let value = slot.borrow().unwrap();
        println!("Borrowed value: {}", value);
        // This would fail at runtime:
        // let value_mut = slot.borrow_mut().unwrap();
    }
    
    slot.release();
    
    {
        let value_mut = slot.borrow_mut().unwrap();
        println!("Borrowed mutable value: {}", value_mut);
    }
    
    slot.release();
    
    // Example 3: Work Stealing Queue
    println!("\n=== Work Stealing Queue Example ===");
    let queue = WorkStealingQueue::new();
    let stealer = queue.clone_stealer();
    
    // Push items
    for i in 0..5 {
        queue.push(i);
    }
    
    // Share work
    queue.share();
    
    // Pop from local
    println!("Popped: {:?}", queue.pop());
    
    // Steal work
    println!("Stolen: {:?}", stealer.steal());
    
    // Example 4: Object Pool
    println!("\n=== Object Pool Example ===");
    let pool = Pool::new();
    
    {
        let mut obj1 = pool.acquire(|| Vec::new());
        obj1.push(1);
        obj1.push(2);
        println!("Using object from pool: {:?}", *obj1);
    } // obj1 returned to pool
    
    {
        let mut obj2 = pool.acquire(|| Vec::new());
        println!("Reused object from pool: {:?}", *obj2);
        obj2.push(3);
        println!("After modification: {:?}", *obj2);
    } // obj2 returned to pool
    
    // Example 5: Custom Reference Counting
    println!("\n=== Custom Rc Example ===");
    let rc1 = CustomRc::new(String::from("Hello, world!"));
    let rc2 = rc1.clone();
    let weak = rc1.downgrade();
    
    println!("Strong count: {}", rc1.strong_count());
    println!("Weak count: {}", rc1.weak_count());
    println!("Value: {}", rc1.get_ref());
    
    drop(rc1);
    println!("After dropping rc1 - Strong count: {}", rc2.strong_count());
    
    let rc3 = weak.upgrade().unwrap();
    println!("Upgraded weak to rc3 - Value: {}", rc3.get_ref());
    
    // Example 6: Ring Buffer
    println!("\n=== Ring Buffer Example ===");
    let mut buffer: RingBuffer<String> = RingBuffer::new(3);
    
    buffer.push_back(String::from("Item 1")).unwrap();
    buffer.push_back(String::from("Item 2")).unwrap();
    buffer.push_back(String::from("Item 3")).unwrap();
    
    // Buffer is full
    let overflow = buffer.push_back(String::from("Overflow"));
    println!("Push result: {:?}", overflow.err().unwrap());
    
    println!("Buffer size: {}/{}", buffer.len(), buffer.capacity());
    
    // Pop items
    while let Some(item) = buffer.pop_front() {
        println!("Popped: {}", item);
    }
}
#+end_src

** Compile-Time Metaprogramming with Procedural Macros

Building powerful code generators and DSLs:

#+begin_src rust :tangle src/proc_macros_demo.rs
//! Demonstration of procedural macros and their usage
//! Note: In a real project, proc macros must be in their own crate
//! This is a simplified example for demonstration

// Example use of procedural macros
// In real code, these would be defined in a separate crate

// The actual implementation would look like this:
// ```
// #[proc_macro_derive(Builder, attributes(builder))]
// pub fn derive_builder(input: TokenStream) -> TokenStream {
//     // Implementation here
// }
// ```

fn main() {
    println!("=== Procedural Macros for Advanced Systems ===");
    println!("This file demonstrates how to use several powerful procedural macros");
    println!("Note: The actual macro implementations would be in a separate crate");
    
    println!("\n=== Example 1: Builder Pattern ===");
    println!(r#"
// Original struct
#[derive(Builder)]
pub struct HttpRequest {
    url: String,
    method: String,
    #[builder(default)]
    headers: HashMap<String, String>,
    #[builder(default = "Vec::new()")]
    body: Vec<u8>,
}

// Generated code allows:
let request = HttpRequestBuilder::default()
    .url("https://example.com")
    .method("GET")
    .header("Content-Type", "application/json")
    .build()
    .unwrap();
"#);

    println!("\n=== Example 2: Command Routing ===");
    println!(r#"
// Routing system for commands
#[command_router]
pub trait CommandHandler {
    #[command(name = "create-user")]
    fn create_user(&self, username: String, email: String) -> Result<(), Error>;
    
    #[command(name = "delete-user")]
    fn delete_user(&self, user_id: u64) -> Result<(), Error>;
    
    #[command(name = "list-users", aliases = ["users", "get-users"])]
    fn list_users(&self) -> Result<Vec<User>, Error>;
}

// Generated code creates a dispatcher:
let handler = MyCommandHandler::new();
let router = CommandRouter::new(handler);

// Can be called with:
router.dispatch("create-user", &["johndoe", "john@example.com"]).unwrap();
"#);

    println!("\n=== Example 3: SQL Query Generator ===");
    println!(r#"
// SQL query builder
#[derive(Queryable)]
#[table(name = "users")]
struct User {
    #[column(primary_key)]
    id: i64,
    username: String,
    #[column(name = "email_address")]
    email: String,
    #[column(nullable)]
    profile_image: Option<String>,
}

// Generated code allows:
let query = User::select()
    .where_eq("username", "johndoe")
    .limit(1)
    .build();
// Produces: "SELECT id, username, email_address, profile_image FROM users WHERE username = ? LIMIT 1"
"#);

    println!("\n=== Example 4: State Machine ===");
    println!(r#"
// Type-safe state machine
#[state_machine]
enum DocumentState {
    #[initial]
    Draft {
        #[transition(to = "UnderReview", with = "submit_for_review")]
        #[transition(to = "Deleted", with = "delete_draft")]
        content: String,
    },
    
    UnderReview {
        #[transition(to = "Published", with = "approve")]
        #[transition(to = "Draft", with = "request_changes")]
        reviewer: String,
        content: String,
    },
    
    Published {
        #[transition(to = "Archived", with = "archive")]
        publication_date: DateTime<Utc>,
        content: String,
    },
    
    Archived {
        archived_date: DateTime<Utc>,
        content: String,
    },
    
    Deleted {
        deletion_date: DateTime<Utc>,
    }
}

// Generated code enforces valid transitions:
let draft = DocumentState::new_draft("Initial content".to_string());
let under_review = draft.submit_for_review("reviewer@example.com".to_string());
let published = under_review.approve(Utc::now());
let archived = published.archive(Utc::now());

// This would be a compile error - no transition defined:
// let draft_again = archived.request_changes();
"#);

    println!("\n=== Example 5: RPC Service Definition ===");
    println!(r#"
// RPC service definition
#[rpc_service]
pub trait UserService {
    #[rpc(name = "get_user")]
    async fn get_user(&self, user_id: u64) -> Result<User, Error>;
    
    #[rpc(name = "create_user")]
    async fn create_user(&self, name: String, email: String) -> Result<User, Error>;
    
    #[rpc(name = "update_user")]
    async fn update_user(&self, user_id: u64, name: Option<String>, email: Option<String>) -> Result<User, Error>;
    
    #[rpc(name = "delete_user")]
    async fn delete_user(&self, user_id: u64) -> Result<(), Error>;
}

// Generated code creates client and server implementations:
// Server:
let service = MyUserServiceImpl::new(db);
let rpc_server = UserServiceServer::new(service);
rpc_server.start("127.0.0.1:8080").await?;

// Client:
let client = UserServiceClient::connect("127.0.0.1:8080").await?;
let user = client.get_user(123).await?;
"#);

    println!("\n=== Implementation of a Builder Macro ===");
    println!(r#"
// Simplified implementation of a Builder macro
#[proc_macro_derive(Builder, attributes(builder))]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    // Parse the input tokens into a syntax tree
    let input = parse_macro_input!(input as DeriveInput);
    
    // Get the name of the struct
    let name = input.ident;
    let builder_name = format_ident!("{}Builder", name);
    
    // Process the fields of the struct
    let fields = match input.data {
        Data::Struct(DataStruct { fields: Fields::Named(fields), .. }) => fields.named,
        _ => panic!("Builder only works on structs with named fields"),
    };
    
    // Generate code for each field
    let field_defs = fields.iter().map(|field| {
        let name = &field.ident;
        let ty = &field.ty;
        
        // Check for #[builder(default)] or #[builder(default = "...")] attributes
        let has_default = field.attrs.iter().any(|attr| {
            attr.path.is_ident("builder") && attr.parse_meta().map_or(false, |meta| {
                match meta {
                    Meta::List(list) => {
                        list.nested.iter().any(|nested| {
                            match nested {
                                NestedMeta::Meta(Meta::Path(path)) => path.is_ident("default"),
                                NestedMeta::Meta(Meta::NameValue(nv)) => nv.path.is_ident("default"),
                                _ => false,
                            }
                        })
                    }
                    _ => false,
                }
            })
        });
        
        if has_default {
            quote! {
                #name: std::option::Option<#ty>,
            }
        } else {
            quote! {
                #name: std::option::Option<#ty>,
            }
        }
    });
    
    // Generate setter methods
    let setters = fields.iter().map(|field| {
        let name = &field.ident;
        let ty = &field.ty;
        
        quote! {
            pub fn #name(&mut self, #name: #ty) -> &mut Self {
                self.#name = std::option::Option::Some(#name);
                self
            }
        }
    });
    
    // Generate build method
    let build_fields = fields.iter().map(|field| {
        let name = &field.ident;
        
        // Check for default value
        let default_expr = field.attrs.iter()
            .filter(|attr| attr.path.is_ident("builder"))
            .filter_map(|attr| {
                attr.parse_meta().ok().and_then(|meta| {
                    match meta {
                        Meta::List(list) => {
                            list.nested.iter().find_map(|nested| {
                                match nested {
                                    NestedMeta::Meta(Meta::NameValue(nv)) if nv.path.is_ident("default") => {
                                        match &nv.lit {
                                            Lit::Str(s) => Some(s.value()),
                                            _ => None,
                                        }
                                    }
                                    _ => None,
                                }
                            })
                        }
                        _ => None,
                    }
                })
            })
            .next();
        
        let has_default = field.attrs.iter().any(|attr| {
            attr.path.is_ident("builder") && attr.parse_meta().map_or(false, |meta| {
                match meta {
                    Meta::List(list) => {
                        list.nested.iter().any(|nested| {
                            match nested {
                                NestedMeta::Meta(Meta::Path(path)) => path.is_ident("default"),
                                _ => false,
                            }
                        })
                    }
                    _ => false,
                }
            })
        });
        
        if let Some(default) = default_expr {
            quote! {
                #name: self.#name.clone().unwrap_or_else(|| #default),
            }
        } else if has_default {
            quote! {
                #name: self.#name.clone().unwrap_or_default(),
            }
        } else {
            quote! {
                #name: self.#name.clone().ok_or_else(|| format!("Missing field: {}", stringify!(#name)))?,
            }
        }
    });
    
    // Generate the final code
    let expanded = quote! {
        pub struct #builder_name {
            #(#field_defs)*
        }
        
        impl #builder_name {
            #(#setters)*
            
            pub fn build(&self) -> std::result::Result<#name, String> {
                Ok(#name {
                    #(#build_fields)*
                })
            }
        }
        
        impl Default for #builder_name {
            fn default() -> Self {
                Self {
                    #(#name: None,)*
                }
            }
        }
        
        impl #name {
            pub fn builder() -> #builder_name {
                #builder_name::default()
            }
        }
    };
    
    TokenStream::from(expanded)
}
"#);
}
#+end_src

** Building High-Performance Parsers

Techniques for building efficient parsers and lexers:

#+begin_src rust :tangle src/parser_combinator.rs
//! Advanced parser combinator library for building high-performance parsers
//! Designed for systems that need to parse complex data formats efficiently

use std::cell::RefCell;
use std::fmt;
use std::iter::Peekable;
use std::marker::PhantomData;
use std::rc::Rc;
use std::str::Chars;

// Type alias for parser results
type ParseResult<'a, T> = Result<(T, &'a str), ParseError>;

// Error type for parsing
#[derive(Debug, Clone, PartialEq)]
pub struct ParseError {
    pub message: String,
    pub position: usize,
}

impl fmt::Display for ParseError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Parse error at position {}: {}", self.position, self.message)
    }
}

// Parser trait - the core of our combinator library
pub trait Parser<'a, T> {
    fn parse(&self, input: &'a str) -> ParseResult<'a, T>;
    
    // Combinators
    fn map<F, U>(self, f: F) -> Map<Self, F, T, U>
    where
        Self: Sized,
        F: Fn(T) -> U,
    {
        Map {
            parser: self,
            map_fn: f,
            _input: PhantomData,
            _output: PhantomData,
        }
    }
    
    fn and_then<F, U, P>(self, f: F) -> AndThen<Self, F, T, U>
    where
        Self: Sized,
        P: Parser<'a, U>,
        F: Fn(T) -> P,
    {
        AndThen {
            parser: self,
            f,
            _input: PhantomData,
            _output: PhantomData,
        }
    }
    
    fn or<P>(self, other: P) -> Or<Self, P, T>
    where
        Self: Sized,
        P: Parser<'a, T>,
    {
        Or {
            left: self,
            right: other,
            _output: PhantomData,
        }
    }
    
    fn pair<P, U>(self, other: P) -> Pair<Self, P, T, U>
    where
        Self: Sized,
        P: Parser<'a, U>,
    {
        Pair {
            left: self,
            right: other,
            _left_output: PhantomData,
            _right_output: PhantomData,
        }
    }
    
    fn left<P, U>(self, other: P) -> Left<Self, P, T, U>
    where
        Self: Sized,
        P: Parser<'a, U>,
    {
        Left {
            left: self,
            right: other,
            _left_output: PhantomData,
            _right_output: PhantomData,
        }
    }
    
    fn right<P, U>(self, other: P) -> Right<Self, P, T, U>
    where
        Self: Sized,
        P: Parser<'a, U>,
    {
        Right {
            left: self,
            right: other,
            _left_output: PhantomData,
            _right_output: PhantomData,
        }
    }
    
    fn many(self) -> Many<Self, T>
    where
        Self: Sized,
        T: Clone,
    {
        Many {
            parser: self,
            _output: PhantomData,
        }
    }
    
    fn many1(self) -> Many1<Self, T>
    where
        Self: Sized,
        T: Clone,
    {
        Many1 {
            parser: self,
            _output: PhantomData,
        }
    }
    
    fn opt(self) -> Opt<Self, T>
    where
        Self: Sized,
        T: Clone,
    {
        Opt {
            parser: self,
            _output: PhantomData,
        }
    }
    
    fn between<P1, P2, U, V>(self, open: P1, close: P2) -> Between<Self, P1, P2, T, U, V>
    where
        Self: Sized,
        P1: Parser<'a, U>,
        P2: Parser<'a, V>,
    {
        Between {
            parser: self,
            open,
            close,
            _output: PhantomData,
            _open_output: PhantomData,
            _close_output: PhantomData,
        }
    }
    
    fn with_context<F>(self, context: F) -> WithContext<Self, F, T>
    where
        Self: Sized,
        F: Fn() -> String,
    {
        WithContext {
            parser: self,
            context,
            _output: PhantomData,
        }
    }
}

// Basic parsers

// Parser for matching a specific character
pub struct Char {
    c: char,
}

impl Char {
    pub fn new(c: char) -> Self {
        Self { c }
    }
}

impl<'a> Parser<'a, char> for Char {
    fn parse(&self, input: &'a str) -> ParseResult<'a, char> {
        if let Some(first) = input.chars().next() {
            if first == self.c {
                let new_input = &input[first.len_utf8()..];
                Ok((first, new_input))
            } else {
                Err(ParseError {
                    message: format!("Expected '{}', found '{}'", self.c, first),
                    position: 0,
                })
            }
        } else {
            Err(ParseError {
                message: format!("Expected '{}', found end of input", self.c),
                position: 0,
            })
        }
    }
}

// Parser for matching a specific string
pub struct Str<'s> {
    s: &'s str,
}

impl<'s> Str<'s> {
    pub fn new(s: &'s str) -> Self {
        Self { s }
    }
}

impl<'a, 's> Parser<'a, &'a str> for Str<'s> {
    fn parse(&self, input: &'a str) -> ParseResult<'a, &'a str> {
        if input.starts_with(self.s) {
            let (matched, rest) = input.split_at(self.s.len());
            Ok((matched, rest))
        } else {
            Err(ParseError {
                message: format!("Expected '{}', found '{}'", self.s, input.chars().next().unwrap_or('\0')),
                position: 0,
            })
        }
    }
}

// Parser for matching a character based on a predicate
pub struct Satisfy<F> {
    predicate: F,
    description: String,
}

impl<F> Satisfy<F>
where
    F: Fn(char) -> bool,
{
    pub fn new(predicate: F, description: &str) -> Self {
        Self {
            predicate,
            description: description.to_string(),
        }
    }
}

impl<'a, F> Parser<'a, char> for Satisfy<F>
where
    F: Fn(char) -> bool,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, char> {
        if let Some(first) = input.chars().next() {
            if (self.predicate)(first) {
                let new_input = &input[first.len_utf8()..];
                Ok((first, new_input))
            } else {
                Err(ParseError {
                    message: format!("Expected {}, found '{}'", self.description, first),
                    position: 0,
                })
            }
        } else {
            Err(ParseError {
                message: format!("Expected {}, found end of input", self.description),
                position: 0,
            })
        }
    }
}

// Combinator parsers

// Map parser: applies a function to the result of another parser
pub struct Map<P, F, T, U> {
    parser: P,
    map_fn: F,
    _input: PhantomData<T>,
    _output: PhantomData<U>,
}

impl<'a, P, F, T, U> Parser<'a, U> for Map<P, F, T, U>
where
    P: Parser<'a, T>,
    F: Fn(T) -> U,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, U> {
        match self.parser.parse(input) {
            Ok((result, rest)) => Ok(((self.map_fn)(result), rest)),
            Err(err) => Err(err),
        }
    }
}

// AndThen parser: applies a function to the result of another parser, returning a new parser
pub struct AndThen<P, F, T, U> {
    parser: P,
    f: F,
    _input: PhantomData<T>,
    _output: PhantomData<U>,
}

impl<'a, P, F, T, U, Q> Parser<'a, U> for AndThen<P, F, T, U>
where
    P: Parser<'a, T>,
    Q: Parser<'a, U>,
    F: Fn(T) -> Q,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, U> {
        match self.parser.parse(input) {
            Ok((result, rest)) => (self.f)(result).parse(rest),
            Err(err) => Err(err),
        }
    }
}

// Or parser: tries one parser, then another if the first fails
pub struct Or<P1, P2, T> {
    left: P1,
    right: P2,
    _output: PhantomData<T>,
}

impl<'a, P1, P2, T> Parser<'a, T> for Or<P1, P2, T>
where
    P1: Parser<'a, T>,
    P2: Parser<'a, T>,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, T> {
        match self.left.parse(input) {
            Ok(result) => Ok(result),
            Err(_) => self.right.parse(input),
        }
    }
}

// Pair parser: runs two parsers in sequence and returns both results
pub struct Pair<P1, P2, T, U> {
    left: P1,
    right: P2,
    _left_output: PhantomData<T>,
    _right_output: PhantomData<U>,
}

impl<'a, P1, P2, T, U> Parser<'a, (T, U)> for Pair<P1, P2, T, U>
where
    P1: Parser<'a, T>,
    P2: Parser<'a, U>,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, (T, U)> {
        match self.left.parse(input) {
            Ok((left_result, rest)) => {
                match self.right.parse(rest) {
                    Ok((right_result, rest)) => Ok(((left_result, right_result), rest)),
                    Err(err) => Err(err),
                }
            }
            Err(err) => Err(err),
        }
    }
}

// Left parser: runs two parsers in sequence and returns the left result
pub struct Left<P1, P2, T, U> {
    left: P1,
    right: P2,
    _left_output: PhantomData<T>,
    _right_output: PhantomData<U>,
}

impl<'a, P1, P2, T, U> Parser<'a, T> for Left<P1, P2, T, U>
where
    P1: Parser<'a, T>,
    P2: Parser<'a, U>,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, T> {
        match self.left.parse(input) {
            Ok((left_result, rest)) => {
                match self.right.parse(rest) {
                    Ok((_, rest)) => Ok((left_result, rest)),
                    Err(err) => Err(err),
                }
            }
            Err(err) => Err(err),
        }
    }
}

// Right parser: runs two parsers in sequence and returns the right result
pub struct Right<P1, P2, T, U> {
    left: P1,
    right: P2,
    _left_output: PhantomData<T>,
    _right_output: PhantomData<U>,
}

impl<'a, P1, P2, T, U> Parser<'a, U> for Right<P1, P2, T, U>
where
    P1: Parser<'a, T>,
    P2: Parser<'a, U>,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, U> {
        match self.left.parse(input) {
            Ok((_, rest)) => self.right.parse(rest),
            Err(err) => Err(err),
        }
    }
}

// Many parser: applies a parser zero or more times
pub struct Many<P, T> {
    parser: P,
    _output: PhantomData<T>,
}

impl<'a, P, T> Parser<'a, Vec<T>> for Many<P, T>
where
    P: Parser<'a, T>,
    T: Clone,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, Vec<T>> {
        let mut results = Vec::new();
        let mut rest = input;
        
        loop {
            match self.parser.parse(rest) {
                Ok((result, new_rest)) => {
                    results.push(result);
                    rest = new_rest;
                }
                Err(_) => break,
            }
        }
        
        Ok((results, rest))
    }
}

// Many1 parser: applies a parser one or more times
pub struct Many1<P, T> {
    parser: P,
    _output: PhantomData<T>,
}

impl<'a, P, T> Parser<'a, Vec<T>> for Many1<P, T>
where
    P: Parser<'a, T>,
    T: Clone,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, Vec<T>> {
        match self.parser.parse(input) {
            Ok((result, rest)) => {
                let mut results = vec![result];
                let mut current_rest = rest;
                
                loop {
                    match self.parser.parse(current_rest) {
                        Ok((result, new_rest)) => {
                            results.push(result);
                            current_rest = new_rest;
                        }
                        Err(_) => break,
                    }
                }
                
                Ok((results, current_rest))
            }
            Err(err) => Err(err),
        }
    }
}

// Opt parser: makes a parser optional
pub struct Opt<P, T> {
    parser: P,
    _output: PhantomData<T>,
}

impl<'a, P, T> Parser<'a, Option<T>> for Opt<P, T>
where
    P: Parser<'a, T>,
    T: Clone,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, Option<T>> {
        match self.parser.parse(input) {
            Ok((result, rest)) => Ok((Some(result), rest)),
            Err(_) => Ok((None, input)),
        }
    }
}

// Between parser: runs a parser between two other parsers
pub struct Between<P, P1, P2, T, U, V> {
    parser: P,
    open: P1,
    close: P2,
    _output: PhantomData<T>,
    _open_output: PhantomData<U>,
    _close_output: PhantomData<V>,
}

impl<'a, P, P1, P2, T, U, V> Parser<'a, T> for Between<P, P1, P2, T, U, V>
where
    P: Parser<'a, T>,
    P1: Parser<'a, U>,
    P2: Parser<'a, V>,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, T> {
        match self.open.parse(input) {
            Ok((_, rest1)) => {
                match self.parser.parse(rest1) {
                    Ok((result, rest2)) => {
                        match self.close.parse(rest2) {
                            Ok((_, rest3)) => Ok((result, rest3)),
                            Err(err) => Err(err),
                        }
                    }
                    Err(err) => Err(err),
                }
            }
            Err(err) => Err(err),
        }
    }
}

// WithContext parser: adds context to error messages
pub struct WithContext<P, F, T> {
    parser: P,
    context: F,
    _output: PhantomData<T>,
}

impl<'a, P, F, T> Parser<'a, T> for WithContext<P, F, T>
where
    P: Parser<'a, T>,
    F: Fn() -> String,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, T> {
        match self.parser.parse(input) {
            Ok(result) => Ok(result),
            Err(err) => {
                Err(ParseError {
                    message: format!("{}: {}", (self.context)(), err.message),
                    position: err.position,
                })
            }
        }
    }
}

// Helper functions to create parsers

// Match a specific character
pub fn char(c: char) -> Char {
    Char::new(c)
}

// Match a specific string
pub fn string<'s>(s: &'s str) -> Str<'s> {
    Str::new(s)
}

// Match a digit character
pub fn digit() -> Satisfy<impl Fn(char) -> bool> {
    Satisfy::new(|c| c.is_ascii_digit(), "digit")
}

// Match a letter character
pub fn letter() -> Satisfy<impl Fn(char) -> bool> {
    Satisfy::new(|c| c.is_ascii_alphabetic(), "letter")
}

// Match an alphanumeric character
pub fn alphanumeric() -> Satisfy<impl Fn(char) -> bool> {
    Satisfy::new(|c| c.is_ascii_alphanumeric(), "alphanumeric")
}

// Match whitespace
pub fn whitespace() -> Satisfy<impl Fn(char) -> bool> {
    Satisfy::new(|c| c.is_whitespace(), "whitespace")
}

// Parse an integer
pub fn integer() -> impl Parser<'static, i64> {
    let digits = digit().many1();
    
    digits.map(|digits| {
        let s: String = digits.into_iter().collect();
        s.parse::<i64>().unwrap()
    })
}

// Example parser for a simple expression language
fn parse_expr<'a>() -> impl Parser<'a, i64> {
    // Forward reference for recursive parsers
    let expr = Rc::new(RefCell::new(None));
    
    // Parse a number
    let number = integer().with_context(|| "parsing number".to_string());
    
    // Parse parenthesized expressions
    let lparen = char('(');
    let rparen = char(')');
    let parens = expr.clone()
        .with_context(|| "parsing parenthesized expression".to_string())
        .between(lparen, rparen);
    
    // Parse a term (number or parenthesized expression)
    let term = number.or(parens);
    
    // Parse operators
    let plus = char('+');
    let minus = char('-');
    let times = char('*');
    let divide = char('/');
    
    // Parse a factor (term followed by * or / and another factor, or just a term)
    let factor_parser = Rc::new(RefCell::new(None));
    
    let factor_op = term.pair(
        (times.or(divide)).pair(factor_parser.clone())
    ).map(|(left, (op, right))| {
        match op {
            '*' => left * right,
            '/' => left / right,
            _ => unreachable!(),
        }
    });
    
    let factor = factor_op.or(term);
    *factor_parser.borrow_mut() = Some(factor.clone());
    
    // Parse an expression (factor followed by + or - and another expression, or just a factor)
    let expr_op = factor.pair(
        (plus.or(minus)).pair(expr.clone())
    ).map(|(left, (op, right))| {
        match op {
            '+' => left + right,
            '-' => left - right,
            _ => unreachable!(),
        }
    });
    
    let expr_parser = expr_op.or(factor);
    *expr.borrow_mut() = Some(expr_parser.clone());
    
    expr_parser
}

// Example of a JSON parser
mod json {
    use super::*;
    
    #[derive(Debug, Clone)]
    pub enum JsonValue {
        Null,
        Boolean(bool),
        Number(f64),
        String(String),
        Array(Vec<JsonValue>),
        Object(Vec<(String, JsonValue)>),
    }
    
    // Parse JSON null
    pub fn null<'a>() -> impl Parser<'a, JsonValue> {
        string("null").map(|_| JsonValue::Null)
    }
    
    // Parse JSON boolean
    pub fn boolean<'a>() -> impl Parser<'a, JsonValue> {
        string("true").map(|_| JsonValue::Boolean(true))
            .or(string("false").map(|_| JsonValue::Boolean(false)))
    }
    
    // Parse JSON number
    pub fn number<'a>() -> impl Parser<'a, JsonValue> {
        // This is a simplified number parser
        let integer_part = digit().many1();
        let fraction_part = char('.').right(digit().many1()).opt();
        
        integer_part.pair(fraction_part).map(|(int_digits, frac_digits)| {
            let mut s = int_digits.iter().collect::<String>();
            
            if let Some(frac) = frac_digits {
                s.push('.');
                s.push_str(&frac.iter().collect::<String>());
            }
            
            JsonValue::Number(s.parse::<f64>().unwrap())
        })
    }
    
    // Parse JSON string
    pub fn string_literal<'a>() -> impl Parser<'a, String> {
        // This is a simplified string parser that doesn't handle all escapes
        let quote = char('"');
        let escape = char('\\').right(
            char('"').or(char('\\')).or(char('/')).or(char('b')).or(char('f'))
                .or(char('n')).or(char('r')).or(char('t'))
        );
        
        let string_char = escape.or(
            Satisfy::new(|c| c != '"' && c != '\\', "string character")
        );
        
        string_char.many().between(quote, quote)
            .map(|chars| chars.iter().collect::<String>())
    }
    
    // Parse JSON string value
    pub fn string<'a>() -> impl Parser<'a, JsonValue> {
        string_literal().map(JsonValue::String)
    }
    
    // Forward declarations for recursive types
    pub fn value<'a>() -> impl Parser<'a, JsonValue> {
        let value_parser = Rc::new(RefCell::new(None));
        
        // JSON array
        let array = {
            let lbracket = char('[');
            let rbracket = char(']');
            let comma = char(',');
            let ws = whitespace().many();
            
            let elements = value_parser.clone()
                .pair(
                    ws.right(comma)
                        .right(ws)
                        .right(value_parser.clone())
                        .many()
                )
                .opt()
                .map(|opt| {
                    match opt {
                        Some((first, rest)) => {
                            let mut elements = vec![first];
                            elements.extend(rest);
                            elements
                        }
                        None => vec![],
                    }
                });
            
            ws.right(elements).left(ws)
                .between(lbracket, rbracket)
                .map(JsonValue::Array)
        };
        
        // JSON object
        let object = {
            let lbrace = char('{');
            let rbrace = char('}');
            let comma = char(',');
            let colon = char(':');
            let ws = whitespace().many();
            
            let pair = string_literal()
                .left(ws)
                .left(colon)
                .left(ws)
                .pair(value_parser.clone());
            
            let pairs = pair
                .pair(
                    ws.right(comma)
                        .right(ws)
                        .right(pair)
                        .many()
                )
                .opt()
                .map(|opt| {
                    match opt {
                        Some((first, rest)) => {
                            let mut pairs = vec![first];
                            pairs.extend(rest);
                            pairs
                        }
                        None => vec![],
                    }
                });
            
            ws.right(pairs).left(ws)
                .between(lbrace, rbrace)
                .map(JsonValue::Object)
        };
        
        // JSON value (any valid JSON value)
        let parser = null()
            .or(boolean())
            .or(number())
            .or(string())
            .or(array)
            .or(object);
        
        *value_parser.borrow_mut() = Some(parser.clone());
        
        parser
    }
}

fn main() {
    println!("=== Advanced Parser Combinators ===");
    
    // Example 1: Basic parsers
    println!("\n--- Basic Parsers ---");
    
    let parser = char('a');
    match parser.parse("abc") {
        Ok((c, rest)) => println!("Parsed: '{}', Rest: '{}'", c, rest),
        Err(e) => println!("Error: {}", e),
    }
    
    let parser = string("hello");
    match parser.parse("hello world") {
        Ok((s, rest)) => println!("Parsed: '{}', Rest: '{}'", s, rest),
        Err(e) => println!("Error: {}", e),
    }
    
    // Example 2: Combinators
    println!("\n--- Combinators ---");
    
    let parser = char('a').or(char('b'));
    match parser.parse("abc") {
        Ok((c, rest)) => println!("Parsed one of 'a' or 'b': '{}', Rest: '{}'", c, rest),
        Err(e) => println!("Error: {}", e),
    }
    
    let parser = char('a').pair(char('b'));
    match parser.parse("abc") {
        Ok(((a, b), rest)) => println!("Parsed pair: '{}' and '{}', Rest: '{}'", a, b, rest),
        Err(e) => println!("Error: {}", e),
    }
    
    // Example 3: Many and Many1
    println!("\n--- Many and Many1 ---");
    
    let parser = digit().many();
    match parser.parse("123abc") {
        Ok((digits, rest)) => {
            let s: String = digits.iter().collect();
            println!("Parsed many digits: '{}', Rest: '{}'", s, rest);
        }
        Err(e) => println!("Error: {}", e),
    }
    
    let parser = letter().many1();
    match parser.parse("abc123") {
        Ok((letters, rest)) => {
            let s: String = letters.iter().collect();
            println!("Parsed many1 letters: '{}', Rest: '{}'", s, rest);
        }
        Err(e) => println!("Error: {}", e),
    }
    
    // Example 4: Integer parser
    println!("\n--- Integer Parser ---");
    
    let parser = integer();
    match parser.parse("123abc") {
        Ok((n, rest)) => println!("Parsed integer: {}, Rest: '{}'", n, rest),
        Err(e) => println!("Error: {}", e),
    }
    
    // Example 5: Expression parser
    println!("\n--- Expression Parser ---");
    
    let parser = parse_expr();
    
    let inputs = [
        "123",
        "123+456",
        "123+456*789",
        "(123+456)*789",
        "1+2*3+4",
    ];
    
    for input in inputs {
        match parser.parse(input) {
            Ok((result, rest)) => {
                if rest.is_empty() {
                    println!("Parsed expression '{}' = {}", input, result);
                } else {
                    println!("Parsed expression '{}' = {}, but had leftover input: '{}'", input, result, rest);
                }
            }
            Err(e) => println!("Error parsing '{}': {}", input, e),
        }
    }
    
    // Example 6: JSON parser
    println!("\n--- JSON Parser ---");
    
    let parser = json::value();
    
    let json_inputs = [
        "null",
        "true",
        "123",
        "\"hello\"",
        "[1, 2, 3]",
        "{\"name\": \"John\", \"age\": 30}",
        "{\"person\": {\"name\": \"John\", \"hobbies\": [\"reading\", \"coding\"]}}",
    ];
    
    for input in json_inputs {
        match parser.parse(input) {
            Ok((result, rest)) => {
                if rest.is_empty() {
                    println!("Parsed JSON: {:?}", result);
                } else {
                    println!("Parsed JSON: {:?}, but had leftover input: '{}'", result, rest);
                }
            }
            Err(e) => println!("Error parsing JSON '{}': {}", input, e),
        }
    }
}
#+end_src